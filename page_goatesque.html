<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0044)https://okmij.org/ftp/ML/generalization.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Efficient and Insightful Generalization</title>
<meta name="description" content="A short guide on OCaml type checker, describing  the surprisingly elegant algorithm for generalization, which generalizes to first-class polymorphism, MLF and local types.  Polymorphism and regions have much in common.">
<meta name="Author" content="oleg-at-okmij.org">
<meta name="Date-Revision-yyyymmdd" content="20220109">
<meta name="Date-Creation-yyyymmdd" content="20130221">

<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="start" href="https://okmij.org/ftp/ML/index.html">
<link rel="prev" href="https://okmij.org/ftp/ML/MetaOCaml.html">
<link rel="next" href="https://okmij.org/ftp/Haskell/regions.html">
<link rel="contents" href="https://okmij.org/ftp/">
<style type="text/css">BODY { background-color: white; color: black } #navbar, h1 { text-align: center; } .small  { font-size: x-small;} LI.separator { list-style-type: none;} LI.header    { list-style-type: none; padding: 1em 0px 2px; margin-left: -1em;}</style></head>
<body>
<div id="navbar"><a href="https://okmij.org/ftp/ML/MetaOCaml.html">previous</a>&nbsp;&nbsp;&nbsp;<a href="https://okmij.org/ftp/Haskell/regions.html">next</a>&nbsp;&nbsp;&nbsp;<a href="https://okmij.org/ftp/ML/index.html">start</a>&nbsp;&nbsp;&nbsp;<a href="https://okmij.org/ftp/">top</a>
<hr></div>
<h1>How OCaml type checker works -- or
what polymorphism and garbage collection have in common</h1>
<div>&nbsp;</div>
<div>There is more to Hindley-Milner type inference than the Algorithm W.
In 1988, Didier Rémy was looking to speed up the type inference in
Caml and discovered an elegant method of type generalization.
Not only it is fast, avoiding scanning the type environment. It
smoothly extends to catching of locally-declared types about to escape,
to type-checking of universals and existentials, and even to MLF.
<p>Alas, both the algorithm and its implementation in the OCaml type
checker are little known and little documented. This page is to
explain and popularize Rémy's algorithm, and to decipher 
a part of the OCaml type checker. The page
also aims to preserve the history of Rémy's algorithm.
</p><p>The attraction of the algorithm is its insight into type
generalization as dependency tracking -- the same sort of tracking
used in automated memory management such as regions and generational
garbage collection. Generalization can be viewed as finding dominators
in the type-annotated abstract syntax tree with edges for shared
types.  Fluet and Morrisett's type system for regions 
use the generalization of a type variable as a
criterion of region containment. Uncannily, Rémy's algorithm views the
region containment as a test if a type variable is generalizable.
</p></div>
<ul>
<li><a href="https://okmij.org/ftp/ML/generalization.html#introduction">Introduction</a>
</li>
<li><a href="https://okmij.org/ftp/ML/generalization.html#generalization">Generalization</a>
</li>
<li><a href="https://okmij.org/ftp/ML/generalization.html#gen-mismanagement">Unsound generalization as memory mismanagement</a>
</li>
<li><a href="https://okmij.org/ftp/ML/generalization.html#levels">Efficient generalization with levels</a>
</li>
<li><a href="https://okmij.org/ftp/ML/generalization.html#levels-lazy">Even more efficient level-based generalization</a>
</li>
<li><a href="https://okmij.org/ftp/ML/generalization.html#regions">Type Regions</a>
</li>
<li><a href="https://okmij.org/ftp/ML/generalization.html#history">Discovery of levels</a>
</li>
<li class="separator">&nbsp;</li>
<li class="header">Inside the OCaml type checker
</li>
<li><a href="https://okmij.org/ftp/ML/generalization.html#levels-OCaml">Generalization with levels in OCaml</a>
</li>
<li><a href="https://okmij.org/ftp/ML/generalization.html#regions">Type Regions</a>
</li>
<li><a href="https://okmij.org/ftp/ML/generalization.html#newtvar">Creating fresh type variables</a>
</li>
<li><a href="https://okmij.org/ftp/ML/generalization.html#gen-in-full">True complexity of generalization</a>
</li></ul>
<hr>

<p>&nbsp;</p>
<h2><a name="introduction">Introduction</a></h2>
<dl>
<dd>This page started as notes taken to understand the OCaml type checking
code, which is extensive, complex and hardly documented. Digging
through the code unearthed real gems. One of them&nbsp;-- an efficient and
elegant method of type generalization&nbsp;-- is spotlight here.
<p>OCaml generalization is based on tracking of so-called <em>levels</em> of a
type.  The very same levels also ensure that types defined
within a module do not escape into a wider scope.  Levels hence
enforce the region discipline for locally introduced type
constructors.  It is intriguing how generalization and regions are
handled so uniformly. There are even more applications of levels in
the OCaml type checker, for records with polymorphic fields and
existentials. MetaOCaml indirectly relied on levels to track the scope
of future-stage bindings.  There is a common refrain in all these
applications: tracking dependencies, computing region containment or
dominators in data-dependency graphs. One is immediately reminded of
the region-based memory management by Tofte and Talpin.  As Fluet and
Morrisett showed, Tofte and Talpin type system for regions can be
encoded in System F, relying on universal quantification to statically
prevent allocated data from escaping their region. Dually, the level-based 
generalization relies on detecting escapes of a type variable
to determine its region and hence the place for its universal
quantification.
</p><p>OCaml's generalization is a (partial) implementation of the algorithm
discovered by Didier Rémy back in 1988. The idea is to explicitly
represent the sharing of types in the type-annotated abstract syntax
tree. A type variable can only be quantified at a node that dominates
all occurrences of that variable. Generalization amounts to the incremental
computation of graph dominators. Rémy's MLF is the natural outgrowth of this
idea.
</p><p>Unfortunately, Rémy's generalization algorithm and the underlying
ideas are little known. The implementations, such as the one in OCaml,
do not seem to be documented at all, aside from a couple of brief
puzzling comments in the OCaml source code. They ought to be widely
known.  Towards this goal, the present page sets to (i) motivate and
explain the algorithm, expose its intuitions and sketch
implementations; (ii) help decipher the OCaml type checker.
</p><p>The second part of this page aims to be a commentary on a portion of the OCaml
type-checker, and is, therefore, quite technical. It refers
to OCaml 4.00.1 type checking code, located in the directory
<code>typing/</code> of the OCaml distribution. The file <code>typecore.ml</code> is the
core type checker: it annotates nodes of the abstract syntax tree with
types and the typing environment. To be precise, it transforms
<code>Parsetree</code> (defined in <code>parsing/parsetree.mli</code>) into <code>Typedtree</code>.
The file <code>ctype.ml</code> implements unification and level manipulation
functions.
</p><p>I am indebted to Didier Rémy for his comments, explanations, insights and
recollections of the discovery of the algorithm. I thank Jacques Garrigue
for helpful comments and explanations of more applications of levels within
the OCaml type checker. Additional references 
provided by Matthew Fluet and Baris Aktemur are gratefully
acknowledged.</p></dd>
<dt><strong>Version</strong></dt>
<dd>The current version is February 2013</dd>
<dt><strong>References</strong></dt>
<dd>Didier Rémy:
Extension of ML Type System with a Sorted Equational Theory on Types<br>

Research Report 1766, Institut National de Recherche en Informatique
et Automatique, Rocquencourt, BP 105, 78 153 Le Chesnay
Cedex, France, 1992<br>

&lt;<a href="http://gallium.inria.fr/~remy/ftp/eq-theory-on-types.pdf">http://gallium.inria.fr/~remy/ftp/eq-theory-on-types.pdf</a>&gt;
<p>Matthew Fluet and J. Gregory Morrisett: Monadic Regions<br>

J. Functional Programming, 2006, v16, N4-5, pp. 485-545<br>

The paper shows that parametric polymorphism is all that needed
for a sound type system of memory regions.
</p></dd></dl>

<p>&nbsp;</p>
<h2><a name="generalization">Generalization</a></h2>
<dl>
<dd>This background section reminds the type generalization in the
Hindley-Milner type system, stressing subtle points and inefficiencies of
the naive implementation. These inefficiencies motivated Rémy's discovery
of the level-based generalization algorithm.
<p>Recall that <em>generalization</em> <code>GEN(G,t)</code> of the type <code>t</code> with respect
to the type environment <code>G</code> is quantifying free type variables of <code>t</code>
that do not occur as free in <code>G</code>. In Greek: <code>GEN(G,t) = ∀ α1 ... αn. t</code> where <code>{α1 ... αn} = FV(t) - FV(G)</code>. In the Hindley-Milner
terminology, this quantification converts a type to a so-called type
schema. Generalization is used in type checking <code>let</code>-expressions:

</p><pre>    G |- e : t    G, (x:GEN(G,t)) |- e2 : t2
    ----------------------------------------
    G |- let x = e in e2 : t2
</pre>That is, the type inferred for the let-bound variable is generalized
when type checking the body of the let-expression.
ML adds a condition
for generalization, so-called value restriction: the let-bound
expression <code>e</code>, by the look of it,
must have no visible side-effects&nbsp;-- technically, <code>e</code> must pass the syntactic
test of being <em>nonexpansive</em>.
OCaml relaxes the value restriction, see later on this page.
<p>Here is a trivial example of generalization:

</p><pre>    fun x -&gt; let y = fun z -&gt; z in y
    (* 'a -&gt; ('b -&gt; 'b) *)
</pre>The type checker infers for <code>fun z -&gt; z</code> the type <code>β-&gt;β</code> with the fresh,
and hence unique, type variable <code>β</code>. 
The expression <code>fun z -&gt; z</code> is syntactically
a value, the generalization proceeds, and <code>y</code> gets
the type <code>∀β.β-&gt;β</code>. Because of the polymorphic type, <code>y</code> may occur in
differently typed contexts&nbsp;-- may be applied to arguments of different 
types,&nbsp;-- as in

<pre>    fun x -&gt; 
      let y = fun z -&gt; z in
      (y 1, y true)
    (* 'a -&gt; int * bool *)
</pre>
<p>Generalization <code>Gen(G,t)</code> quantifies over only those free type variables of <code>t</code>
that do not occur in <code>G</code>. This condition is subtle
but crucial: without it, the unsound type <code>α-&gt;β</code> is inferred for
the function

</p><pre>    fun x -&gt; let y = x in y
</pre>To wit: to infer the function's type, we infer the type of its body
<code>let y = x in y</code>
in the environment in which <code>x:α</code> where <code>α</code> is a fresh type
variable. According to the <code>let</code>-rule above the type inferred for <code>y</code>,
and hence the result type is <code>Gen(x:α,α)</code>. Clearly <code>α</code> does occur in
the environment <code>x:α</code>. If we quantify over it nevertheless, <code>y</code>
receives the polymorphic type <code>∀α.α</code>, which can then be instantiated
to any type. The result is the function that ostensibly converts its
argument to the value of any type whatsoever.
<p>Thus, for each type variable to quantify we must make sure that it
does not occur in the type environment. Naively, we could scan the
type environment looking through the type of each binding -- in fact,
the original Caml did exactly that. The type environment however can
get very large. Typically ML functions contain long sequences of
<code>let</code>-expressions. A non-recursive <code>let</code> has in its type environment
the bindings of all previous <code>let</code>s; the environment of a recursive
<code>let</code> has the bindings of all <code>let</code> siblings.  Scanning the
environment as part of the generalization for a single <code>let</code> takes
time linear in the function size; type checking of the whole
program will be quadratic then. (Except for pathological cases,
Hindley-Milner type inference scales nearly linearly with the program
size.)  The inefficient generalization was one of the main reasons for
the slow speed of Caml compilation, Didier Rémy recalls.
Bootstrapping the compiler and type checking two mutually recursive
functions for compiling patterns and expressions took 20 minutes.
</p><p>There has to be a way to avoid scanning the environment. The 
next section gives the idea.</p></dd></dl>

<p>&nbsp;</p>
<h2><a name="gen-mismanagement">Unsound generalization as memory mismanagement</a></h2>
<dl>
<dd>This section begins to introduce the ideas behind Rémy's algorithm,
relating them to region-based memory management. For concreteness we
will be using a toy Hindley-Milner type inferencer. In this section,
the inferencer has the <em>unsound</em> generalization function that
quantifies free type variables in a type with no regard for the
environment.  We type check in detail three simple examples, and
relate the inferring of unsound types with the common problems of
manual memory management: releasing memory still in use. The unsound
generalization will be fixed in the next section, drawing
the inspiration from the standard methods of preventing premature
deallocation of resources.
<p>Although our Hindley-Milner type inferencer is toy, it shares many
implementation decisions (and even some function names) with the real
OCaml type checker. Understanding it will help when we turn to OCaml
internals later on this page.
</p><p>Our toy language is the standard pure lambda-calculus with <code>let</code>.
Its expressions are:

</p><pre>    type exp = 
      | Var of varname                      (* variable                *)
      | App of exp * exp                    (* application: e1 e2      *)
      | Lam of varname * exp                (* abstraction: fun x -&gt; e *)
      | Let of varname * exp * exp          (* let x = e in e2         *)
</pre>Types are comprised of (free or bound) type variables, quantified type variables
and function types:

<pre>    type qname = string
    type typ = 
      | TVar of tv ref               (* type (schematic) variable *)
      | QVar of qname                (* quantified type variable  *)
      | TArrow of typ * typ
    and tv = Unbound of string | Link of typ
</pre>Types with <code>QVar</code> are type schemas; without&nbsp;-- simple types.  Type
schemas, i.e. quantified types, in the Hindley-Milner system are in
the prenex form (that is, universal quantifiers are all outside), and
so the quantifiers need not be represented explicitly.
<p>In the Prolog tradition, type variables are represented as reference cells.
An unbound variable contains the null or the self pointer -- or, in our case,
the name of the variable for easy printing. When a free type variable is
unified with some type <code>t'</code>, the reference cell is overwritten with the
pointer to <code>t'</code>. To prevent cyclical (and, for us, unsound) types,
the `occurs check' is performed first: <code>occurs tv t'</code> traverses <code>t'</code> raising
an exception if it comes across the type variable <code>tv</code>:

</p><pre>    let rec unify : typ -&gt; typ -&gt; unit = fun t1 t2 -&gt;
      if t1 == t2 then ()                   (* t1 and t2 are physically the same *)
      else match (t1,t2) with
      | (TVar {contents = Link t1},t2) 
      | (t1,TVar {contents = Link t2}) -&gt; 
          unify t1 t2
      | (TVar ({contents = Unbound _} as tv),t') 
      | (t',TVar ({contents = Unbound _} as tv)) -&gt; 
          occurs tv t'; tv := Link t'
      | (TArrow (tyl1,tyl2), TArrow (tyr1,tyr2)) -&gt;
          unify tyl1 tyr1;
          unify tyl2 tyr2
      (* everything else is error *)
</pre>
<p>The type checker is completely standard. It infers the type for the
expression <code>exp</code> in the type environment <code>env</code>:

</p><pre>    type env = (varname * typ) list
    let rec typeof : env -&gt; exp -&gt; typ = fun env -&gt; function
      | Var x     -&gt; inst (List.assoc x env)
      | Lam (x,e) -&gt; 
          let ty_x = newvar () in
          let ty_e = typeof ((x,ty_x)::env) e in
          TArrow(ty_x,ty_e)
      | App (e1,e2) -&gt;
          let ty_fun = typeof env e1 in
          let ty_arg = typeof env e2 in
          let ty_res = newvar () in
          unify ty_fun (TArrow (ty_arg,ty_res));
          ty_res
      | Let (x,e,e2) -&gt; 
          let ty_e = typeof env e in
          typeof ((x,gen ty_e)::env) e2
</pre>The function <code>newvar</code> allocates a new <code>TVar</code>, with a unique name.
The function <code>inst</code> instantiates a type schema, that is, 
replaces each <code>QVar</code> with a fresh <code>TVar</code>. It is also standard.
The generalization function is unsound: it quantifies all free variables
in the type regardless of the environment:

<pre>    let rec gen : typ -&gt; typ = function      (* unsound! *)
      | TVar {contents = Unbound name} -&gt; QVar name
      | TVar {contents = Link ty}      -&gt; gen ty
      | TArrow (ty1,ty2)               -&gt; TArrow (gen ty1, gen ty2)
      | ty -&gt; ty
</pre>The quantification replaces a <code>TVar</code> with the corresponding <code>QVar</code>.
The original <code>TVar</code> is hence implicitly deallocated: When a free variable is
bound, it `disappears', being replaced by the `pointer' to the binder.
<p>With respect to type variables, <code>typeof</code> allocates free variables,
unifies them, and deallocates, after quantification.
Let us type check simple examples observing the sequence of these
three main operations that affect free type variables. The first example 
is the one where nothing should go wrong:

</p><pre>    fun x -&gt; let y = fun z -&gt; z in y
</pre>The trace of type-checking, showing only type-variable related operations,
is as follows:

<pre>    1    ty_x = newvar ()          (* fun x -&gt; ...               *)
    2      ty_e =                  (* let y = fun z -&gt; z in y    *)
    3         ty_z = newvar ();    (* fun z -&gt; ...               *)
    3         TArrow(ty_z,ty_z)    (* inferred for: fun z -&gt; z   *)
    2      ty_y = gen ty_e         (* ty_z remains free, and so  *)
    2      deallocate ty_z         (* quantified and disposed of *)
    1    TArrow(ty_x, inst ty_y)   (* inferred for: fun x -&gt; ... *)
</pre>The number in the first column is the depth for the recursive invocations
of <code>typeof</code>. Since <code>typeof</code> recurs on each non-leaf node of the abstract
syntax tree (AST), this recursive invocation depth is the depth in the AST
of the node being type checked. The inferred type is <code>'a -&gt; 'b -&gt; 'b</code>,
as expected. Nothing went wrong.
<p>The second example, also seen earlier, is the one for which the unsound
generalization gives the unsound type <code>'a-&gt;'b</code>:

</p><pre>    fun x -&gt; let y = x in y
</pre>Diagramming the <code>TVar</code> operations as before reveals the problem:

<pre>    1    ty_x = newvar ()          (* fun x -&gt; ...                 *)
    2      ty_e =                  (* let y = x in y               *)
    3         inst ty_x            (* inferred for x, same as ty_x *)
    2      ty_y = gen ty_e         (* ty_x remains free, and is    *)
    2      deallocate ty_x         (* quantified, and disposed of  *) 
    1    TArrow(ty_x, inst ty_y)   (* inferred for: fun x -&gt; ...   *)
</pre>The type variable <code>ty_x</code> is part of the return type, used at depth 1&nbsp;--
and yet it is quantified and disposed of at depth 2. We disposed
of the value still in use.
<p>The third example is also problematic. The unsound generalization again
gives the unsound type <code>('a-&gt;'b) -&gt; ('c -&gt;'d)</code>:

</p><pre>    fun x -&gt; let y = fun z -&gt; x z in y
</pre>The diagram shows a memory management problem again:

<pre>    1    ty_x = newvar ()          (* fun x -&gt; ...               *)
    2      ty_e =                  (* let y = ...                *)
    3         ty_z = newvar ()     (* fun z -&gt; ...               *)
    4           ty_res = newvar () (* typechecking: x z          *)
    4           ty_x :=            (* as the result of unify     *)
    4              TArrow (ty_z,ty_res)
    4           ty_res             (* inferred for: x z          *)
    3         TArrow(ty_z,ty_res)  (* inferred for: fun z -&gt; x z *)
    2      ty_y = gen ty_e         (* ty_z, ty_res remain free   *)
    2      deallocate ty_z         (* quantified and disposed of *)
    2      deallocate ty_res       (* quantified and disposed of *)
    1    TArrow(ty_x, inst ty_y)   (* inferred for: fun x -&gt; ... *)
</pre>The type variables <code>ty_z</code> and <code>ty_res</code> are quantified over and
hence disposed of at depth 2, and yet they are part of
<code>TArrow (ty_z,ty_res)</code> that is assigned to <code>ty_x</code>, which, in turn,
is part of the result.
<p>All unsound examples had a `memory management problem', deallocating
memory (<code>TVar</code>) still being used. This is no accident. When a type
variable is quantified over, later on it can be instantiated with any
type whatsoever. However, a type variable that appears in the type
environment cannot be replaced with any type without affecting the
rest of the type checking.  Likewise, when we free a piece of memory,
we give the run-time the permission to reallocate it and overwrite
with arbitrary data.  The rest of our program should not depend on
what happens later with the deallocated memory -- provided it was
really free, not needed further in the program. In fact, one may
define `memory not in use' as arbitrary changes to that memory not
affecting the rest of the program. Deallocating memory still in use
will affect the rest of the program -- often, crash it. Incidentally,
unsound types inferred for our examples often lead to the same result.</p></dd>
<dt><strong>References</strong></dt>
<dd><a href="https://okmij.org/ftp/ML/generalization/unsound.ml">unsound.ml</a>&nbsp;[11K]<br>

Complete code for the toy type inferencer with the unsound
generalization, with many more examples of unsound inference
</dd></dl>

<p>&nbsp;</p>
<h2><a name="levels">Efficient generalization with levels</a></h2>
<dl>
<dd>This section continues the exposition of the ideas behind Rémy's
algorithm. Now that we have seen how the unsound generalization
relates to releasing memory still in use, we apply the standard
remedy for premature deallocation&nbsp;-- ownership tracking, or
regions&nbsp;-- and cure the unsound generalization without much
overhead. We develop two algorithms. The simpler one, <code>sound_eager</code>,
is motivated and explained in this section. The optimal
<code>sound_lazy</code>, which captures the main features of the Rémy algorithm,
is presented next.
<p>Clearly, before deallocating memory we must check if it is still in
use.  Naively, we could scan all memory known to be in use looking
for references to the deallocation candidate&nbsp;-- in other words, do the
full garbage-collection marking pass and see if our candidate
got marked. Put this way, the check seems awfully expensive.  At
least we should wait until garbage accumulates, to collect en
masse. Alas, in the Hindley-Milner type system we cannot delay
quantification arbitrarily, since the generalized type may
be used right away.
</p><p>More promising is ownership tracking: associating an allocated resource
with an owner, an object or a function activation. Only the owner may
deallocate its resources. A similar strategy is regions, which are
areas of heap memory created by a lexically-scoped
so-called <code>letregion</code> primitive.  When <code>letregion</code> goes out of scope, its whole
whole region is summarily deallocated. This idea matches the
generalization well. In the Hindley-Milner system, generalization is
always a part of <code>let</code>. A <code>let</code>-expression <code>let x = e in e2</code> is the
natural owner of all type variables allocated when inferring the type
of <code>e</code>. When the type of <code>e</code> is found, all free type variables still
owned by the <code>let</code>-expression can be disposed of, that is, quantified.
</p><p>These intuitions underlie the sound and efficient generalization
algorithms. The first is <code>sound_eager</code>, described in the rest of the
section. Its code differs only in small, but significant, details from
the toy Hindley-Milner inferencer from the previous section. We will
explain only these differences; the complete code is available
below. The main difference is that free type variables, albeit
unbound, are now owned, and refer to their owner. The
owner, always a <code>let</code> expression, is identified by a positive integer
called <em>level</em>. It is the De Bruijn level, or the nesting depth,
of the owing 
<code>let</code>-expression. Level 1 corresponds to the (implicit) top-level
<code>let</code>.  (Incidentally, although both <code>let</code>s in <code>(let x = e1 in eb1, let y = e2 in eb2)</code> have level 2, no confusion can arise as neither
<code>let</code> is in each other scope and hence their regions are disjoint.)
The <code>let</code>-nesting depth is equal to the <code>let</code>-expression's
type checking recursion depth, which is
is simple to determine, with the help of one reference cell.

</p><pre>    type level = int
    let current_level = ref 1
    let enter_level () = incr current_level
    let leave_level () = decr current_level
</pre>The type inferencer maintains the <code>let</code> type-checking depth:

<pre>    let rec typeof : env -&gt; exp -&gt; typ = fun env -&gt; function
      ... (* the other cases are the same as before *)
      | Let (x,e,e2) -&gt; 
          enter_level ();
          let ty_e = typeof env e in
          leave_level ();
          typeof ((x,gen ty_e)::env) e2
</pre>The only change to the main type-inference function was adding
<code>enter_level</code> and <code>leave_level</code> to track the level. The rest of <code>typeof</code> is
literally the same as in the original toy version.
<p>Free type variables now carry the level identifying their owner.
A freshly allocated type variable receives the <code>current_level</code>, meaning that
its owner is the latest <code>let</code> being type-checked. (In region-based
memory management, all new memory is allocated in the innermost alive
region.)

</p><pre>    type typ = 
      | TVar of tv ref               (* type (schematic) variable *)
      | QVar of qname                (* quantified type variable *)
      | TArrow of typ * typ
    and tv = Unbound of string * level | Link of typ
   
    let newvar : unit -&gt; typ =
     fun () -&gt; TVar (ref (Unbound (gensym (),!current_level)))
</pre>
<p>Just as an assignment may change the owner of an allocated piece of
memory, unification may change the level of a free type variable. For
example, if <code>ty_x</code> (level 1) and <code>ty_y</code> (level 2) are both free and
<code>ty_x</code> is unified with the type <code>TArrow(ty_y,ty_y)</code>, the arrow type
and its components are exported into region 1, and so the level of
<code>ty_y</code> is changed to 1. One may view the above unification as
replacing all occurrences of <code>ty_x</code> with <code>TArrow(ty_y,ty_y)</code>. Since
<code>t_x</code> has a smaller level and may hence occur outside the inner,
level-2 <code>let</code>, after the bound-expression of that inner
<code>let</code> is type-checked <code>ty_y</code> should not be deallocated.  With the
updated <code>ty_y</code> level, it won't be. All in all, unifying a free type
variable <code>ty_x</code> with <code>t</code> has to update the level of each free type
variable <code>ty_y</code> in <code>t</code> to the smallest of <code>ty_y</code> and <code>ty_x</code>
levels. Unifying a free type variable with <code>t</code> also has to do the
occurs check, which too traverses the type. The two traversals can be
merged. The new <code>occurs</code> does the occurs check and updates the levels:

</p><pre>    let rec occurs : tv ref -&gt; typ -&gt; unit = fun tvr -&gt; function
      | TVar tvr' when tvr == tvr' -&gt; failwith "occurs check"
      | TVar ({contents = Unbound (name,l')} as tv) -&gt;
          let min_level = 
            (match !tvr with Unbound (_,l) -&gt; min l l' | _ -&gt; l') in
          tv := Unbound (name,min_level)
      | TVar {contents = Link ty} -&gt; occurs tvr ty
      | TArrow (t1,t2)            -&gt; occurs tvr t1; occurs tvr t2
      | _ -&gt; ()
</pre>
<p>The only difference from the original <code>occurs</code> code is the second clause
in the pattern-match. The unification code does not have to be modified 
at all. Finally, we fix the generalization function, to make it sound:

</p><pre>    let rec gen : typ -&gt; typ = function
      | TVar {contents = Unbound (name,l)} 
          when l &gt; !current_level -&gt; QVar name
      | TVar {contents = Link ty} -&gt; gen ty
      | TArrow (ty1,ty2) -&gt; TArrow (gen ty1, gen ty2)
      | ty -&gt; ty
</pre>
<p>The change is minimal: the condition <code>when l &gt; !current_level</code>. Recall
the new <code>typeof</code> code:

</p><pre>    let rec typeof : env -&gt; exp -&gt; typ = fun env -&gt; function
      ... (* the other cases are the same as before *)
      | Let (x,e,e2) -&gt; 
          enter_level ();
          let ty_e = typeof env e in
          leave_level ();
          typeof ((x,gen ty_e)::env) e2
</pre>It invokes <code>gen</code> after the region established for type checking <code>e</code>
exits. A free type variable still owned by that region will have
the level greater than the current. Since the region is now dead,
any such type variable may be deallocated, that is, quantified.
<p>These are all the changes of <code>sound_eager</code> from the unsound toy algorithm,
which fix the type inference. Here is the old problematic example

</p><pre>    fun x -&gt; let y = x in y
</pre>Diagramming the <code>TVar</code> operations shows no problems now:

<pre>    1  1   ty_x/1 = newvar ()          (* fun x -&gt; ...                 *)
    2  2     ty_e =                    (* let y = x in y               *)
    3  2        inst ty_x/1            (* inferred for x, same as ty_x *)
    2  1     ty_y = gen ty_e           (* ty_x/1 remains free, but is  *)
                                       (* level = current, can't       *)
                                       (* quantify, can't dispose      *)
    1  1   TArrow(ty_x/1, inst ty_y)   (* inferred for: fun x -&gt; ...   *)
</pre>The first column of numbers shows the <code>typeof</code> recursion depth, or the depth
of the AST node being type-checked. The number in the second column is
the <code>current_level</code>, the <code>let</code>-nesting depth. We write the level
of a free type variable after the slash, as in <code>ty_x/1</code>. 
That variable is no longer quantified by <code>gen</code> at depth 2 (level 1)
since <code>ty_x/1</code> belongs to to the current, still active region 1. 
Therefore, the inferred type is <code>'a-&gt;'a</code>, as expected.
<p>In a slightly more complex example,

</p><pre>    fun x -&gt; let y = fun z -&gt; x in y
</pre>the type variable <code>ty_x</code> for the type of <code>x</code> is allocated at level 1,
whereas <code>ty_z</code> is allocated at level 2. After the inner <code>let</code>, region
2, is finished, <code>ty_z/2</code> will be quantified and disposed of, but
<code>ty_x/1</code> will not. The inferred type therefore is <code>'a-&gt;'b-&gt;'a</code>.  The
reader is encouraged to diagram other examples, to check that 
the inferred types are sound.
<p>Level tracking may look like reference counting. However, rather than
counting the number of users for a free type variable, we keep track
of only one user, the one with the widest scope. Level tracking does
look a lot like generational garbage collection: Memory is allocated
in the young generation, and summarily disposed of at minor
(youngest) collection, unless it is `re-parented' or referenced
from the stack. The old generation does not have to be scanned for
references to the new generation, since no such references are
expected&nbsp;-- unless there was an assignment of a (pointer to a) 
young value to a
field of an old data structure. A generational garbage collector
(such OCaml GC) keeps track of young-to-old assignments. At
minor collection, young data referred from the old are promoted to the
old generation. Type generalization indeed looks very similar to the
minor GC collection.
</p></dd>
<dt><strong>References</strong></dt>
<dd><a href="https://okmij.org/ftp/ML/generalization/sound_eager.ml">sound_eager.ml</a>&nbsp;[13K]<br>

The complete code for the toy type inferencer with the <code>sound_eager</code>
generalization, with many more examples of now sound inference
</dd></dl>

<p>&nbsp;</p>
<h2><a name="levels-lazy">Even more efficient level-based generalization</a></h2>
<dl>
<dd>This section continues the exposition of the ideas behind Rémy's
algorithm and presents <code>sound_lazy</code>: an optimized version of
<code>sound_eager</code> from the previous section. The <code>sound_lazy</code> algorithm
eschews repeated, unnecessary traversals of a type during unification,
generalization and instantiation, and avoids copying the parts
that do not contain variables to generalize or instantiate, thus
improving sharing. The algorithm delays the occurs check and the level
updates, so that the unification with a free type variable takes
constant time. Levels are updated incrementally and on demand. All in
all, <code>sound_lazy</code> embodies the main ideas of Rémy's algorithm. Some of
these ideas are implemented in the OCaml type checker.
<p>To carry on the optimizations, we change the syntax of types. Recall
that in <code>sound_eager</code>, types were comprised of free or bound type
variables <code>TVar</code>, (implicitly universally) quantified type variables
<code>QVar</code> and function types <code>TArrow</code>. The first, seemingly unprincipled
change, is to eliminate <code>QVar</code> as a distinct alternative and dedicate
a very large positive integer -- which should be treated as the
inaccessible ordinal ω&nbsp;-- as a <code>generic_level</code>.  A free type variable
<code>TVar</code> at <code>generic_level</code> is taken to be a quantified type
variable. More substantially, all types, not only free type variables,
have levels now. The level of a composite type (<code>TArrow</code> in our case)
is an upper, not necessarily exact, bound on the levels of its
components. In other words, if a type belongs to an alive region, all
its components should be alive.  It immediately follows that if a
(composite) type is at <code>generic_level</code>, it may contain quantified type
variables.  Contrapositively, if a type is not at <code>generic_level</code>, it
does not contain any quantified variable. Therefore, instantiating
such a type should return the type as it is without traversing
it. Likewise, if the level of a type is greater than the current
level, it may contain free type variables to generalize. On the other
hand, the generalization function should not even bother traversing a
type whose level is equal or less than the current. This is the first
example of how levels help eliminate excessive traversals and
rebuildings of a type, improving sharing.
</p><p>Unifying a type with a free type variable should update the type's level
to the level of the type variable if the latter level is smaller. For a
composite type, such an update means recursively updating the 
levels of all components of the type. To postpone costly traversals, we 
give composite types two levels: <code>level_old</code> is an upper
bound on the levels of type's components; <code>level_new</code>, which is less or
equal to <code>level_old</code>, is the level the type should have after the update.
If <code>level_new &lt; level_old</code>, the type has pending level updates. The
syntax of types in <code>sound_lazy</code> is thus

</p><pre>    type level = int
    let generic_level = 100000000           (* as in OCaml typing/btype.ml *)
    let marked_level  = -1                  (* for marking a node, to check*)
                                            (* for cycles                  *)
    type typ = 
      | TVar of tv ref
      | TArrow of typ * typ * levels
    and tv = Unbound of string * level | Link of typ
    and levels = {mutable level_old : level; mutable level_new : level}
</pre>
<p>We have not explained <code>marked_level</code>. The occurs check on each
unification with a free type variable is expensive, raising the
algorithmic complexity of the unification and type checking. We now
postpone this check, until the whole expression is type checked. In
the meanwhile, unification may create cycles in types. Type traversals
have to check for cycles, or risk divergence. The <code>marked_level</code> is
assigned temporarily to <code>level_new</code> of a composite type to indicate
the type is being traversed. Encountering <code>marked_level</code> during a
traversal means detecting a cycle, which raises the occurs check
error. Incidentally, in OCaml types are generally cyclic:
(equi-)recursive types arise when type checking objects and
polymorphic variants, and when the <code>-rectypes</code> compiler option is set.  The
OCaml type checker uses a similar marked-level trick to detect cycles
and avoid divergence.
</p><p>The <code>sound_lazy</code> unification has several important differences 
from <code>sound_eager</code>:

</p><pre>    let rec unify : typ -&gt; typ -&gt; unit = fun t1 t2 -&gt;
      if t1 == t2 then ()                   (* t1 and t2 are physically the same *)
      else match (repr t1,repr t2) with
      | (TVar ({contents = Unbound (_,l1)} as tv1) as t1,      (* unify two free vars *)
        (TVar ({contents = Unbound (_,l2)} as tv2) as t2)) -&gt;
         if tv1 == tv2 then ()             (* the same variable *)
         else
           if l1 &gt; l2 then tv1 := Link t2 else tv2 := Link t1  (* bind the higher-level var *)
      | (TVar ({contents = Unbound (_,l)} as tv),t')
      | (t',TVar ({contents = Unbound (_,l)} as tv)) -&gt; 
          update_level l t';
          tv := Link t'
      | (TArrow (tyl1,tyl2,ll), TArrow (tyr1,tyr2,lr)) -&gt;
          if ll.level_new = marked_level || lr.level_new = marked_level then
            failwith "cycle: occurs check";
          let min_level = min ll.level_new lr.level_new in
          ll.level_new &lt;- marked_level; lr.level_new &lt;- marked_level;
          unify_lev min_level tyl1 tyr1;
          unify_lev min_level tyl2 tyr2;
          ll.level_new &lt;- min_level; lr.level_new &lt;- min_level
      (* everything else is the unification error *)
   
    and unify_lev l ty1 ty2 =
      let ty1 = repr ty1 in
      update_level l ty1;
      unify ty1 ty2
</pre>where the auxiliary <code>repr</code>, like OCaml's <code>Btype.repr</code>, chases links of
bound variables returning a free variable or a constructed type.
Unlike OCaml, we do path compression.  The unification function no
longer does the occurs check; therefore, it has to make an effort to
detect accidentally created cycles. Unifying with a free variable now
takes constant time, to bind the variable after a shallow
<code>update_level</code>.
<p>The function <code>update_level</code> is one of the key parts of the optimized
algorithm. Often, it merely promises to update the level of a type to 
the given level. It works in
constant time and maintains the invariant that a type level may
only decrease. The level of a type variable is updated immediately.
For a composite type, <code>level_new</code> is
set to the desired new level if the latter is smaller. In
addition, if previously <code>level_new</code> and <code>level_old</code> were the same, the
type is put into the <code>to_be_level_adjusted</code> queue for later 
update of the levels of the components. This work queue is akin to
the list of assignments into the old generation from the young
maintained by a generational garbage collector (such as the one in
OCaml). 

</p><pre>    let to_be_level_adjusted = ref []
   
    let update_level : level -&gt; typ -&gt; unit = fun l -&gt; function
      | TVar ({contents = Unbound (n,l')} as tvr) -&gt; 
          assert (not (l' = generic_level));
          if l &lt; l' then
            tvr := Unbound (n,l)
      | TArrow (_,_,ls) as ty -&gt; 
          assert (not (ls.level_new = generic_level));
          if ls.level_new = marked_level then failwith "occurs check";
          if l &lt; ls.level_new then begin
            if ls.level_new = ls.level_old then
              to_be_level_adjusted := ty :: !to_be_level_adjusted;
            ls.level_new &lt;- l
          end
      | _ -&gt; assert false
</pre>
<p>The pending level updates must be performed before generalization:
After all, a pending update may decrease the level of a type variable,
promoting it to a wider region and hence saving it from
quantification. Not all pending updates have to be forced however --
only of those types whose <code>level_old &gt; current_level</code>. Otherwise, a
type contains no variables generalizable at the present point, and the
level update may be delayed further. The described forcing algorithm
is implemented by <code>force_delayed_adjustments</code>, see the source
code. Incidentally, if a level update of a composite type (<code>TArrow</code>)
has to be really performed, the type has to be traversed.  Unification
of two <code>TArrow</code> types also has to traverse them. Therefore,
unification could, in principle, also update the levels along the
way. That optimization is not currently implemented, however.
</p><p>The generalization function searches for free <code>TVar</code>s that belong to a
dead region (that is, whose level is greater than the current) and
sets their level to <code>generic_level</code>, hence quantifying the
variables. The function traverses only those parts of the type that
may contain type variables to generalize. If a type has the (new)
level of <code>current_level</code> or smaller, all its components belong to live
regions and hence the type has nothing to generalize.  After the
generalization, a composite type receives <code>generic_level</code> if it
contains a quantified type variable. Later on, the instantiation
function will, therefore, only look through those types whose
level is <code>generic_level</code>.

</p><pre>    let gen : typ -&gt; unit = fun ty -&gt;
      force_delayed_adjustments ();
      let rec loop ty =
        match repr ty with
        | TVar ({contents = Unbound (name,l)} as tvr)
               when l &gt; !current_level -&gt;
          tvr := Unbound (name,generic_level)
        | TArrow (ty1,ty2,ls) when ls.level_new &gt; !current_level -&gt;
          let ty1 = repr ty1 and ty2 = repr ty2 in
          loop ty1; loop ty2;
          let l = max (get_level ty1) (get_level ty2) in
          ls.level_old &lt;- l; ls.level_new &lt;- l   (* set the exact level upper bound *)
        | _ -&gt; ()
      in loop ty
</pre>
<p>The type checker <code>typeof</code> remains the same, entering a new region when
type checking a <code>let</code> expression. Please see the source code for details.
</p><p>We have presented the optimized <code>sound_lazy</code> type generalization algorithm
that avoids not only scanning the whole type environment on each
generalization, but also the occurs check on each
unification with a free type variable. In the result, unification takes
constant time. The algorithm eliminates unnecessary type traversals
and copying, saving time and memory.  Two ideas underlie the
optimizations, besides the type levels for free type variables. First
is the assigning of levels to composite types, to give us an idea what
a type may contain without looking though it. The second principle is
delaying expensive actions (type traversals) with the hope they will
get done in the future alongside of something else. In other words, if
dealing with a problem is postponed long enough, it may go away:
procrastination sometimes helps.</p></dd>
<dt><strong>References</strong></dt>
<dd><a href="https://okmij.org/ftp/ML/generalization/sound_lazy.ml">sound_lazy.ml</a>&nbsp;[20K]<br>

The complete code for the optimized toy type inferencer,
again with many examples
</dd></dl>

<p>&nbsp;</p>
<h2><a name="levels-OCaml">Generalization with levels in OCaml</a></h2>
<dl>
<dd>This OCaml internals section describes the implementation of
the type levels in the OCaml type checker and their application for 
efficient generalization. The next section shows how the levels
help prevent escapes of local types and type check existentials.
<p>The ideas behind the type generalization in OCaml have been presented in the
previous sections, in the form of the toy algorithms <code>sound_eager</code> and
<code>sound_lazy</code>. Their code has been intentionally written to 
resemble the OCaml type checker, often using the same function names.
The OCaml type checker implements the <code>sound_eager</code>
algorithm with a few optimizations from <code>sound_lazy</code>. OCaml is far
more complicated: whereas unification in the toy code takes just
a few lines, the OCaml unification code, in <code>ctype.ml</code>, takes
1634 lines. Nevertheless, understanding the toy algorithms should help
in deciphering the OCaml type checker.
</p><p>Like the <code>sound_eager</code> algorithm, the OCaml type checker does the
occurs check and the levels update on each unification with a free
variable; one can clearly see that from the code of <code>Ctype.unify_var</code>.
On the other hand, like in <code>sound_lazy</code>, the OCaml type checker
assigns levels to all types, not only to type variables -- see
<code>type_expr</code> in <code>types.mli</code>. One reason is to detect escaping local
type constructors (described in the next section).  Also like in
<code>sound_lazy</code>, <code>generic_level</code> distinguishes quantified type variables
and the types that may contain quantified variables (so-called
`generic types').  Therefore, the schema instantiation function
<code>Ctype.instance</code> and <code>Ctype.copy</code> will not traverse and copy
non-generic parts of a type, returning them as they are, which
improves sharing.  Type variables at <code>generic_level</code> are printed like
<code>'a</code>; with other levels, as <code>'_a</code>.  As in
our toy algorithms, a mutable global <code>Ctype.current_level</code> tracks the
current level, which is assigned to newly created types or type
variables (see <code>Ctype.newty</code> and <code>Ctype.newvar</code>). The <code>current_level</code>
is increased by <code>enter_def()</code> and decreased by <code>end_def()</code>.  Besides
the <code>current_level</code>, there is also <code>nongen_level</code>, used when type
checking a class definition, and <code>global_level</code> used for type
variables in type declarations.
</p><p>A very simplified code for type-checking <code>let x = e in body</code> is 
as follows.

</p><pre>    let e_typed =
      enter_def ();
      let r = type_check env e_source in
      end_def (); 
      r
    in
    generalize e_typed.exp_type;
    let new_env = bind env x e_typed.exp_type in
    type_check new_env body_source
</pre>Here, <code>e_source</code> is the abstract syntax tree, or
<code>Parsetree.expression</code> for the expression <code>e</code> and <code>e_typed</code> is the
<code>Typedtree.expression</code>, the abstract syntax tree in which each node is
annotated with its inferred type, the field <code>exp_type</code>.
<p>Thus the overall type generalization pattern, 
often seen in the OCaml type checker, is

</p><pre>    let ty =
        enter_def ();
        let r = ... let tv = newvar() in ... (... tv ...)
        end_def ();
        r in
    generalize ty
</pre>
<p>If <code>tv</code> was not unified with something that existed in the environment
before <code>enter_def()</code>, the variable will be generalized. The code looks
quite like our toy code.
</p><p>Interestingly, levels have another use, enforcing the region 
discipline for local type declarations.</p></dd></dl>

<p>&nbsp;</p>
<h2><a name="regions">Type Regions</a></h2>
<dl>
<dd>The OCaml type checker relies on type levels also to check that
types are not used before being declared and that locally introduced
types do not escape into a wider scope. Unification, akin to assignment, 
facilitates both mischiefs. We have seen how type levels are
related to region-based memory management. It is not surprising then
that the levels help rein in the unification, preventing resource 
mismanagement -- this time, not with type variables but with type constants.
<p>OCaml, unlike SML, supports local modules, or modules defined in
local scope, via the <code>let module</code> form. A local module may declare a type,
and may even let this type escape, as in

</p><pre>    let y =
      let module M = struct 
            type t = Foo 
            let x = Foo 
          end 
      in M.x
         ^^^
    Error: This expression has type M.t but an expression was expected of type 'a
           The type constructor M.t would escape its scope
</pre>Such an escape must be flagged as an error. Otherwise, 
<code>y</code> will receive the type <code>M.t</code> where
<code>M.t</code> and even <code>M</code> are not in scope where <code>y</code> is. This problem is
akin to returning the address of an automatic local variable from 
a C function:

<pre>    char * esc_res(void)
    {
      char str [] = "local string";
      return str;
    }
</pre>A locally declared type can escape not only through the result type but also by
unification with an existing type variable:

<pre>    fun y -&gt; 
      let module M = struct 
            type t = Foo 
            let r = y Foo 
          end 
      in ()
                      ^^^
    Error: This expression has type t but an expression was expected of type 'a
           The type constructor t would escape its scope
</pre>This sort of error is also familiar to C programmers:

<pre>    char * y = (char*)0;
    void esc_ext(void)
    {
      char str [] = "local string";
      y = str;
    }
</pre>
<p>Even top-level modules have type
escaping problems. Here is the example taken from a comment in the OCaml
type checker:

</p><pre>    let x = ref []
    module M = struct 
       type t 
       let _ = (x : t list ref)
    end
</pre>The variable <code>x</code> has the non-generic type <code>'_a list ref</code>. 
The module <code>M</code> defines the local type <code>t</code>. 
The type attribution causes <code>x</code>,
defined prior to <code>t</code>, to have the type <code>x : t list ref</code>.
It looks like <code>t</code> is used before defined.
Such type escaping may occur even without modules, as pointed by
Jacques Garrigue:

<pre>    let r = ref []
    type t = Foo
    let () = r := [Foo]
                   ^^^
    Error: This expression has type t but an expression was expected of type 'weak1
           The type constructor t would escape its scope
</pre>OCaml cannot
let such escapes go uncaught. Under no circumstances a type
constructor may be used outside the scope of its declaration. Type
levels enforce this region-like discipline for type constructors.
<p>The OCaml type checker already supports regions for the sake of type
generalization, providing operations <code>begin_def</code> for entering and
<code>end_def</code> for exiting (destroying) a new region, associating types to
their owner region, and tracking ownership changes during
unification. What remains is to make a type declaration enter a new
region and to associate the declared type constructor with this
region. Any type in which this type constructor appears must belong to
a region within the type declaration region: the declaration of a type
constructor must dominate all its uses.
</p><p>As explained earlier, type regions are identified by a positive
integer, type level: the nesting depth of the region. Each type has
the field <code>level</code> with the level of its owner region. Type
constructors would need a similar level annotation. It turns out, a
different facility of OCaml serves exactly this purpose. Type
constructors, data constructors, term variables may be re-defined
within an OCaml program: a type can be re-declared, a variable can be
rebound several times.  OCaml relies on <em>identifiers</em> (see <code>ident.ml</code>)
to distinguish among differently declared or bound occurrences of the
same name. An identifier has the name and the timestamp, a positive
number. The global mutable <code>Ident.currentstamp</code> keeps the `current
time' and advances it when a new identifier is created, by a
declaration or a binding. The timestamp of the identifier is thus its
binding time. The binding time is the natural way to relate an
identifier to a type region. If the current time is set to the current
level, new identifiers will have their binding time not smaller than
the current level: they will be regarded as owned by the current type
region. Non-escaping then means that the level of a type is no less
than the binding time of each type constructor within the type.
</p><p>Unification, specifically, unification with a free type
variable&nbsp;-- akin to assignment&nbsp;-- may change the ownership of a type,
and so has to update the type level accordingly. It can also check, at
the same time, that the non-escaping property still holds: see
<code>Ctype.update_level</code>.
</p><p>We can now understand the OCaml code for type checking a local module,
the expression <code>let module name = modl in body</code>, excerpted below
from <code>typecore.ml</code>.

</p><pre>    | Pexp_letmodule(name, smodl, sbody) -&gt;
        let ty = newvar() in
        (* remember the original level *)
        begin_def ();
        Ident.set_current_time ty.level;
        let context = Typetexp.narrow () in
        let modl = !type_module env smodl in
        let (id, new_env) = Env.enter_module name.txt modl.mod_type env in
        Ctype.init_def(Ident.current_time());
        Typetexp.widen context;
        let body = type_expect new_env sbody ty_expected in
        (* go back to original level *)
        end_def ();
        (* Check that the local types declared in modl don't escape
           through the return type of body
        *)
        begin try
          Ctype.unify_var new_env ty body.exp_type
        with Unify _ -&gt;
          raise(Error(loc, Scoping_let_module(name.txt, body.exp_type)))
        end;
        re {
          exp_desc = Texp_letmodule(id, name, modl, body);
          exp_loc = loc; exp_extra = [];
          exp_type = ty;
          exp_env = env }
</pre>
<p>The type variable <code>ty</code> is created to receive the inferred type
of the expression. The variable is created in the current region. After
that, a new type region is entered, by <code>begin_def()</code>, and the
identifier timestamp clock is set to correspond to the new <code>current_level</code>.
(The timestamp clock is advanced right before a new identifier is
created. That's why <code>Ident.set_current_time</code> receives <code>ty.level</code> rather
than the incremented <code>current_level</code> as the argument.) 
Any type constructor declared within the the local module
will hence have the binding time of <code>current_level</code> or higher.
<code>Ctype.init_def(Ident.current_time())</code> sets the type level to be
the binding time of the last identifier of the local module. Therefore, all
fresh types created afterwards, when type checking the <code>body</code>,
will have the level greater or equal than the binding time of 
any local module's type constructor. The unification will watch
that any level update preserve the invariant. Finally, the
unification with <code>ty</code> at the very end (whose region, recall, is outside
the <code>let module</code>'s region) will make sure than none of the local
type constructors escape through the return type.
</p><p>Incidentally, <code>Typetexp.narrow ()</code> and <code>Typetexp.widen context</code>
in the above code establish a new context for type variables within
the local module. That's why

</p><pre>    fun (x:'a) -&gt; let module M = struct let g (x:'a) = x end in M.g
</pre>has the inferred type <code>'a -&gt; 'b -&gt; 'b</code> rather than <code>'a -&gt; 'a -&gt; 'a</code>. The two
occurrences of <code>'a</code> in the above code are the distinct type variables. A local
module shares none of its type variables with the surrounding.
<p>Existential types are quite like the types declared in local modules:
in fact, existentials can be implemented with first-class local modules.
Therefore, checking that types created by pattern-matching on
(or, opening of) an existential do not escape the pattern-matching
clause uses the same technique: see <code>Typecore.type_cases</code>.</p></dd></dl>

<p>&nbsp;</p>
<h2><a name="history">Discovery of levels</a></h2>
<dl>
<dd>Didier Rémy has discovered the type generalization algorithm based on
levels when working on his Ph.D. on type inference of records and
variants. (Incidentally, he calls 'levels' ranks&nbsp;-- alas, 'levels' is
the term now used in the OCaml type checker.) He prototyped his record
inference in the original Caml (Categorical Abstract Machine
Language), which was written in Caml itself and ran on the top of Le
Lisp.  That was before Caml Light let alone OCaml. He had to recompile
Caml frequently, which took a long time. As he says, the type
inference of Caml was the bottleneck: ``The heart of the compiler code
were two mutually recursive functions for compiling expressions and
patterns, a few hundred lines of code together, but taking around 20
minutes to type check!  This file alone was taking an abnormal
proportion of the bootstrap cycle.  This was at the time when
recompiling fonts in LaTeX would also take forever, so I think we were
used to scheduling such heavy tasks before coffee breaks&nbsp;-- or the
other way round.''  The type inference in Caml was slow for several
reasons. First, the instantiation of a type schema would create a new
copy of the entire type&nbsp;-- even of the parts without quantified
variables, which can be shared instead. Doing the occurs check on
every unification of a free type variable (as in our eager toy
algorithm), and scanning the whole type environment on each
generalization increase the time complexity of inference.
<p>Didier Rémy resolved to speed up the process. He says:

</p><blockquote>
<div>``So, when I wrote my prototype for type checking records and variants (which,
being structural, tend to be much larger then usual ML types), I was very
careful to stay close to the theory in terms of complexity.

<ul>
<li>I implemented unification on graphs in <code>O(n log n)</code>---doing path
compression and postponing the occurs-check;
</li>
<li>I kept the sharing introduced in types all the way down without breaking
it during generalization/instantiation;
</li>
<li>finally, I introduced the rank-based type generalization.''
</li></ul></div></blockquote>This efficient type inference algorithm was described in Rémy's PhD
dissertation (in French) and in the 1992 technical report.  The
<code>sound_lazy</code> algorithm explained earlier was a very simple model of
Rémy's algorithm, representing its main features.  Xavier Leroy
implemented the type levels and the level-based generalization in
Caml-Light. However, for various reasons he implemented the version
akin to <code>sound_eager</code>, with the occurs check on each binding of a free
type variable.
<p>Didier Rémy prefers to view ranks, or levels, in terms of graphs. If
we add to the abstract syntax tree type annotations on each node,
edges for shared types and edges from a quantified variable to its
quantifier, we obtain a graph. The level of a free type variable can
be thought of as the De Bruijn level&nbsp;-- the pointer to the AST node that
will quantify the type variable. That AST node must be a <code>let</code> node,
in the Hindley-Milner system.  Unifying two free variables adds a
sharing edge between them, which requires the adjustment of levels to
maintain the invariant that a quantifier node dominates all uses of
its bound variables.  (Recall, a dominator in a graph for a set of
nodes <code>V</code> is a node <code>d</code> such that all paths from the root to each node
in <code>V</code> pass through <code>d</code>.)  Adding the sharing edge may create a path that
no longer passes through the old dominator, letting the variable
escape, so to speak, and become dominated by a <code>let</code> node with a
wider scope.
</p><p>The graphical view of the ranks proved fruitful. Rank-based generalization
easily extends to type checking of records with polymorphic fields.
Eventually this graphical view has led to MLF. Didier Rémy remarks that
``the main operation in MLF -- raising binders -- is analogous to the 
computation of minimal rank between two nodes.'' Rémy's two MLF talks
below describe the system and show several animations of rank adjustments
during type checking. He also points out how ranks fit with 
the constraint-based presentation of ML type inference,
explained in ``The Essence of ML Type Inference''.</p></dd>
<dt><strong>References</strong></dt>
<dd>A History of Caml<br>

&lt;<a href="http://caml.inria.fr/about/history.en.html">http://caml.inria.fr/about/history.en.html</a>&gt;<br>

Section ``The first implementation'' describes the original Caml.

<p>François Pottier and Didier Rémy. The Essence of ML Type Inference<br>

In Advanced Topics in Types and Programming Languages
(Benjamin C. Pierce, editor)<br>

Chapter 10, pages 389-489. MIT Press, 2005.

</p><p>Didier Rémy:
Extension of ML Type System with a Sorted Equational Theory on Types<br>

Research Report 1766, Institut National de Recherche en Informatique
et Automatique, Rocquencourt, BP 105, 78 153 Le Chesnay
Cedex, France, 1992<br>

&lt;<a href="http://gallium.inria.fr/~remy/ftp/eq-theory-on-types.pdf">http://gallium.inria.fr/~remy/ftp/eq-theory-on-types.pdf</a>&gt;

</p><p>Didier Rémy: A new look on MLF<br>

&lt;<a href="http://cristal.inria.fr/~remy/mlf/portland.pdf">http://cristal.inria.fr/~remy/mlf/portland.pdf</a>&gt;

</p><p>Didier Rémy: MLF for Everyone (Users, Implementers, and Designers)<br>

&lt;<a href="http://cristal.inria.fr/~remy/mlf/mlf-for-everyone.pdf">http://cristal.inria.fr/~remy/mlf/mlf-for-everyone.pdf</a>&gt;

</p><p>David McAllester: A logical algorithm for ML type inference
Proc. RTA'03, pp. 436-451<br>

David McAllester has much later re-discovered the efficient
generalization. He also showed that the ML type inference is
nearly linear in program size for most practical programs.

</p><p>George Kuan and David MacQueen:
Efficient ML Type Inference Using Ranked Type Variables<br>

ML Workshop 2007<br>

&lt;<a href="http://people.cs.uchicago.edu/~gkuan/pubs/ml07-km.pdf">http://people.cs.uchicago.edu/~gkuan/pubs/ml07-km.pdf</a>&gt;<br>

The paper compares two level-based Hindley-Milner inference algorithms:
one uses <code>let</code>-levels, as explained on this page, while
the other relies on lambda-levels. The paper develops abstract
machines for both algorithms and describes their several interesting
formal properties. The lambda-level approach was used in SML/NJ.

</p><p>Peter Sestoft: Programming Language Concepts<br>

Springer Undergraduate Texts in Computer Science. xiv + 278 pages.
July 2012<br>

&lt;<a href="http://www.itu.dk/people/sestoft/plc/">http://www.itu.dk/people/sestoft/plc/</a>&gt;<br>

Chapter 6 (see lecture slides and examples on the above page) describes a
simpler version of Rémy's algorithm -- essentially, <code>sound_eager</code>.
</p></dd></dl>

<p>&nbsp;</p>
<h2><a name="newtvar">Creating fresh type variables</a></h2>
<dl>
<dd>The OCaml type checker provides two functions to create a fresh type
variable.  This section illustrates the difference between them. The
functions are defined in <code>ctype.ml</code>, with the following signatures:

<pre>    newvar    : ?name:string -&gt; unit -&gt; type_exp
    newgenvar : ?name:string -&gt; unit -&gt; type_exp
</pre>Both take the optional argument <code>?name</code> to give the name to the
variable. The name will be chosen automatically otherwise.
<p>The function <code>newvar</code> creates a variable at the <code>current_level</code> whereas
<code>newgenvar</code> creates at the <code>generic_level</code>. In the code

</p><pre>    let ty1 = newvar () in
    unify env ty1 some_type
 
    let ty2 = newgenvar () in
    unify env ty2 some_type
</pre>both <code>ty1</code> and <code>ty2</code> behave the same: the type variable will be bound
to <code>some_type</code>. Since the <code>current_level</code> corresponds to the innermost
alive region, <code>some_type</code>'s level is the current level or smaller,
and so remains unchanged in either case.
<p>The difference emerges in the following two snippets
(the second often occurs in <code>typecore.ml</code>)

</p><pre>    let ty1 = newvar () in
    let list_type = newgenty (Tconstr(p_list, [ty1])) in
    let texp = instance env list_type in
    unify env texp some_type

    let ty2 = newgenvar () in
    let list_type = newgenty (Tconstr(p_list, [ty2])) in
    let texp = instance env list_type in
    unify env texp some_type
</pre>The function <code>instance</code> copies the type -- creates a <code>Tsubst</code> node, to be
precise&nbsp;-- only if the type is generic. That is, in

<pre>    let ty = newvar () in instance env ty
</pre><code>instance</code> acts as the identity function. However, in

<pre>    let ty = newgenvar () in instance env ty
</pre><code>instance</code> copies the variable. Therefore, in the first snippet above,
<code>unify</code> at the end may affect the <code>list_type</code>, by instantiating <code>ty1</code>.
The <code>list_type</code> cannot possibly be affected in the second snippet since
<code>unify</code> will act on the copy of <code>ty2</code>.</dd></dl>

<p>&nbsp;</p>
<h2><a name="gen-in-full">True complexity of generalization</a></h2>
<dl>
<dd>The <code>let</code>-generalization in OCaml is far more complex than what we
have sketched earlier. This section is to help appreciate the true
complexity of generalization.
<p>The <code>let</code>-expression in OCaml has the general form

</p><pre>    let [rec] pattern = exp and pattern = exp ... in body
</pre>The <code>let</code> type checker <code>type_let</code> -- 160 lines of code in
<code>typecore.ml</code>, not counting the type checking of patterns -- receives
the list of pattern-expression pairs, and the recursion-flag. Here is
the end of its code

<pre>    begin_def ();
    ...
    let exp_list =
     List.map2
       (fun (spat, sexp) (pat, slot) -&gt; .... (* type checking of expressions *)
         type_expect exp_env sexp pat.pat_type)
       spat_sexp_list pat_slot_list in
    ...
    end_def();
    List.iter2
      (fun pat exp -&gt;
         if not (is_nonexpansive exp) then
           iter_pattern (fun pat -&gt; generalize_expansive env pat.pat_type) pat)
      pat_list exp_list;
    List.iter
      (fun pat -&gt; iter_pattern (fun pat -&gt; generalize pat.pat_type) pat)
      pat_list;
    (List.combine pat_list exp_list, new_env, unpacks)
</pre>We see the familiar pattern:

<pre>    begin_def(); ... newvar () ... end_def(); generalize
</pre>But there is another traversal of the type, with
<code>generalize_expansive</code>. That function is invoked only if the expression
is expansive, that is, may have a visible effect -- for example, it is
an application.  The function <code>Ctype.generalize_expansive</code>
traverses its argument <code>type_expression</code>; when it comes across a
constructed type <code>Tconstr(p,args)</code> (such as the list type, etc),
and is about to traverse an <code>arg</code>, <code>generalize_expansive</code> checks
the declaration of the type <code>p</code> for the variance of that argument.
If <code>arg</code> is covariant, <code>generalize_expansive</code> traverses <code>arg</code> and
sets the levels of the components above the <code>current_level</code> to 
the <code>generic_level</code>. If <code>arg</code> is not covariant (e.g., the argument of
<code>ref</code> and <code>array</code> type constructors), <code>arg</code>'s components with
the levels above the current are set to the <code>current_level</code>.
The subsequent <code>generalize</code> will leave those levels as they
are. This is how a so-called relaxed value restriction is
implemented, which is responsible for inferring the polymorphic type for

<pre>    # let x = (fun y -&gt; print_string "ok"; y) [];;
    ok
    val x : 'a list = []
</pre>Here, <code>x</code> is bound to an application, which is not a syntactically
value and which is expansive. Its evaluation certainly has a visible
effect.  And yet the type of <code>x</code> is generalized because the <code>list</code>
type is covariant in its argument. SML would not have.
</dd>
<dt><strong>References</strong></dt>
<dd>Jacques Garrigue: Relaxing the Value Restriction<br>

FLOPS 2004, pp. 196-213
</dd></dl>
<div id="footer">
<div>&nbsp;</div>
<hr>
<h3>Last updated January 9, 2022</h3>This site's top page is <a href="http://okmij.org/ftp/"><strong>http://okmij.org/ftp/</strong></a><br>

<div><cite>oleg-at-okmij.org</cite><br>
Your comments, problem reports, questions are very welcome!</div>
<div class="small">Generated by MarXere</div></div></body></html>